{
    "filename": "arbitraryJump",
    "version": 0,
    "_comment_developer": [
        "@dev: @QAN"
    ],
    "_comment_language": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Solidity",
            "Rust",
            "Cairo"
        ]
    },
    "language": "Solidity",
    "_comment_language_version": {
        "cardinality_min": 1,
        "cardinality_max": 2,
        "example": [
            "version_min : 0.8,",
            "version_max : null,"
        ]
    },
    "language_version": {
        "version_min": "0.1.2",
        "version_max": null
    },
    "_comment_blockchain": {
        "cardinality_min": 1,
        "cardinality_max": 9999,
        "example": [
            "Ethereum",
            "Base",
            "Base",
            "ZKSync"
        ]
    },
    "blockchain": [
        "Ethereum"
    ],
    "_comment_specification_DID": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "specification_DID shall be unique among all the verifications",
            "CWE-695 : Use of Low-Level Functionality"
        ]
    },
    "specification_DID": "SWC-127",
    "_comment_name": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Name purpose is only internal name module"
        ]
    },
    "name": "Arbitrary jump with function type variable",
    "_comment_title": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Title will be exported to produced reports as a risk title"
        ]
    },
    "title": "Arbitrary jump with function type variable",
    "_comment_criticity": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "GAS",
            "NC",
            "LOW",
            "MEDIUM",
            "HIGH"
        ]
    },
    "criticity": "LOW",
    "_comment_pattern": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
     "In json \\ will be a 'single antislash' in regex as a string",
     "mstore     : Matches the literal string 'mstore'     'mstore'"
        ]
    },
    "pattern": "(mstore)",
    "_comment_conditionalPattern": {
        "cardinality_min": 0,
        "cardinality_max": 1,
        "example": [
            "((?=.*import)(?=.*UUPSUpgradeable).*)"
        ]
    },
    "conditionalPattern": null,
    "_comment_description": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Description will be exported to produced reports as a risk description"
        ]
    },
    "description": "Solidity supports function types. That is, a variable of function type can be assigned with a reference to a function with a matching signature. The function saved to such variable can be called just like a regular function. The problem arises when a user has the ability to arbitrarily change the function type variable and thus execute random code instructions. As Solidity doesn't support pointer arithmetics, it's impossible to change such variable to an arbitrary value. However, if the developer uses assembly instructions, such as *mstore* or assign operator, in the worst case scenario an attacker is able to point a function type variable to any code instruction, violating required validations and required state changes.<br>\n [Source1](https://swcregistry.io/docs/SWC-127) <br>\n",
    "_comment_recommendation": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Recommendation will be exported to produced reports as a risk mitigation proposotion"
        ]
    },
    "recommendation": "The use of assembly should be minimal. A developer should not allow a user to assign arbitrary values to function type variables.",
    "_comment_gasSaving": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "0",
            "1",
            "666"
        ]
    },
    "gasSaving": 0,
    "_comment_impact": {
        "cardinality_min": 0,
        "cardinality_max": 1,
        "example": [
            "null"
        ]
    },
    "impact": null,
    "_comment_startLineModifier": {
        "cardinality_min": 0,
        "cardinality_max": 1,
        "example": [
            "null"
        ]
    },
    "startLineModifier": null,
    "_comment_endLineModifier": {
        "cardinality_min": 0,
        "cardinality_max": 1,
        "example": [
            "null"
        ]
    },
    "endLineModifier": null,
    "_comment_category": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Regex"
        ]
    },
    "category": "Regex",
    "_comment_specification_EN": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "specification_EN => Export LATEX"
        ]
    },
    "specification_EN": "If precondition is found in the solidity file: import 'IAccount' foundry era interface then all the 'payForTransaction' functions definitions whitout any 'require' are founded. If it is found, then add a match to dowsers database.",
    "_comment_specification_FR": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "specification_FR => Export LATEX"
        ]
    },
    "specification_FR": "",
    "_comment_specification_MATH": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "specification_MATH => Export LATEX"
        ]
    },
    "specification_MATH": " ",
    "_comment_contractType": {
        "cardinality_min": 1,
        "cardinality_max": 9999,
        "example": [
            "ERC20",
            "ERC1271",
            "ERC6492",
            "Ownable",
            "Upgradable",
            "Auction"
        ]
    },
    "contractType": [
        "ERC20",
        "ERC1271",
        "ERC6492",
        "Ownable",
        "Upgradable"
    ],
    "_comment_risk": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "SAFETY",
            "FINANCE",
            "COMPLIANCE",
            "COMMUNICATION",
            "ECOLOGY"
        ]
    },
    "risk": "SAFETY",
    "_comment_scenario": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "Les tokens ne sont pas transférables",
            "Le contrat est détruit",
            "L'attaquant réalise une enchère faible qui ne peut pas être dépassée",
            "Le cout en gas fee est important"
        ]
    },
    "scenario": "The funds are lost",
    "_comment_subScenario": {
        "cardinality_min": 0,
        "cardinality_max": 1,
        "example": [
            "L'utilisateur est blacklisté",
            "La fonction Transfer ne marche pas",
            "La fonction TransferFrom ne marche pas"
        ]
    },
    "subScenario": "Transfer function doesnt work",
    "_comment_property": {
        "cardinality_min": 1,
        "cardinality_max": 1,
        "example": [
            "SAFETY_POSSIBLE_BLACKLIST",
            "SAFETY_RULE_ERC20_2_SECURED_TRANFSERFROM",
            "SAFETY_RULE_ERC20_10_SANDWICH_ATTACK",
            "ECOLOGY_OPTIMIZATION"
        ]
    },
    "property": "SAFETY_RULE_ERC20_2_SECURED_TRANSFER"
}
